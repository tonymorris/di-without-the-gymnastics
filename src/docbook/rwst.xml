<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"[
    <!ENTITY ellipsis "&#8230;">
    ]>

<sect1 id="RWST" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Reader/Writer/State Transformer</title>
  <subtitle>The King of Injecting Dependencies</subtitle>
  <sect2>
    <title>Putting it All Together</title>
    <itemizedlist>
      <listitem>
        <para>
          Dependency Injection is, at its essence, a specialisation of the reader/writer/state monad transformer.
        </para>
      </listitem>
      <listitem>
        <para>
          The what what transformer?
        </para>
      </listitem>
    </itemizedlist>
  </sect2>
  <sect2>
    <title>RWS Transformer in Scala</title>
    <programlisting>
case class ReaderWriterStateT[R, W, S, F[_], A](
  run: (R, S) => F[(W, A, S)]
) {
  def map[B](f: A => B)(implicit F: Functor[F])
      : ReaderWriterStateT[R, W, S, F, B] =
    ReaderWriterStateT {
      case (r, s) => F.map(run(r, s)) {
        case (w, a, s) => (w, f(a), s)
      }
    }

  def flatMap[B](f: A => ReaderWriterStateT[R, W, S, F, B])
                (implicit F: Bind[F], W: Semigroup[W])
      : ReaderWriterStateT[R, W, S, F, B] =
    ReaderWriterStateT {
      case (r, s) => F.flatMap(run(r, s)) {
        case (w1, a, s1) => F.map(f(a) run (r, s1)) {
          case (w2, b, s2) => (W.op(w1, w2), b, s2)
        }
      }
    }
}

object ReaderWriterStateT {
  type ReaderWriterState[R, W, S, A] =
    ReaderWriterStateT[R, W, S, Id, A]
}

case class ReaderT[A, F[_], B](
  rd: A => F[B]
) {
  def rws[W, S](implicit F: Functor[F], W: Monoid[W])
      : ReaderWriterStateT[A, W, S, F, B] =
    ReaderWriterStateT {
      case (r, s) => F.map(rd(r))(
        (W.id, _, s)
      )
    }
}

object ReaderT {
  type Reader[A, B] =
    ReaderT[A, Id, B]
}

case class WriterT[W, F[_], A](
  wx: F[(W, A)]
) {
  def rws[R, S](implicit F: Functor[F])
      : ReaderWriterStateT[R, W, S, F, A] =
    ReaderWriterStateT {
      case (r, s) => F.map(wx){
        case (w, a) => (w, a, s)
      }
    }
}

object WriterT {
  type Writer[W, A] =
    WriterT[W, Id, A]
}

case class StateT[S, F[_], A](
  st: S => F[(A, S)]
) {
  def rws[W, R](implicit F: Functor[F], W: Monoid[W])
      : ReaderWriterStateT[R, W, S, F, A] =
    ReaderWriterStateT {
      case (r, s) => F.map(st(s)){
        case (a, s) => (W.id, a, s)
      }
    }
}

object StateT {
  type State[S, A] =
    StateT[S, Id, A]
}

case class Id[A](a: A)

object Id {
  implicit val IdMonad: Monad[Id] =
    new Monad[Id] {
      def point[A](a: => A) = Id(a)
      def bind[A, B](f: A => Id[B]) =
        i => f(i.a)
    }
}

trait Functor[F[_]] {
  def fmap[A, B](f: A => B): F[A] => F[B]
  def map[A, B](a: F[A])(f: A => B): F[B] =
    fmap(f)(a)
}

trait Bind[F[_]] extends Functor[F] {
  def bind[A, B](f: A => F[B]): F[A] => F[B]
  def flatMap[A, B](a: F[A])(f: A => F[B]): F[B] =
    bind(f)(a)
}

trait Semigroup[A] {
  def op(a1: A, a2: A): A
}

trait Monoid[A] extends Semigroup[A] {
  def id[A]: A
}</programlisting>
  </sect2>
  <sect2>
    <title>RWS Transformer in Haskell</title>
    <programlisting>
newtype ReaderWriterStateT r w s f a =
  ReaderWriterStateT {
    run :: (r, s) -> f (w, a, s)
  }

instance Functor f =>
  Functor (ReaderWriterStateT r w s f) where
  fmap f (ReaderWriterStateT x) =
    ReaderWriterStateT $
      fmap (\(w, a, s) -> (w, f a, s)) . x

instance (Bind f, Semigroup w) =>
  Bind (ReaderWriterStateT r w s f) where
  bind f (ReaderWriterStateT x) =
    ReaderWriterStateT $ \(r, s) ->
      bind (\(w1, a, s1) ->
        fmap (\(w2, b, s2) ->
          (op w1 w2, b, s2))
          (run (f a) (r, s1))) (x (r, s))

type ReaderWriterState r w s a =
  ReaderWriterStateT r w s Id a

newtype ReaderT a f b =
  ReaderT { rd :: a -> f b }

rwsR (ReaderT f) =
  ReaderWriterStateT $ \(r, s) ->
    fmap (\z -> (identity, z, s)) (f r)

type Reader a b =
  ReaderT a Id b

newtype WriterT w f a =
  WriterT { wx :: f (w, a) }

rwsW (WriterT x) =
  ReaderWriterStateT $ \(r, s) ->
    fmap (\(w, a) -> (w, a, s)) x

type Writer w a =
  WriterT w Id a

newtype StateT s f a =
  StateT { st :: s -> f (a, s) }

rwsS (StateT f) =
  ReaderWriterStateT $ \(r, s) ->
    fmap (\(a, s) -> (identity, a, s)) (f s)

type State s a =
  StateT s Id a

newtype Id a = Id a

instance Functor Id where
  fmap f (Id a) = Id (f a)

instance Bind Id where
  bind f (Id a) = f a

class Functor f => Bind f where
  bind :: (a -> f b) -> f a -> f b

class Semigroup a where
  op :: a -> a -> a

class Semigroup a => Monoid a where
  identity :: a</programlisting>
  </sect2>
</sect1>
